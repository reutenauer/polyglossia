\NeedsTeXFormat{LaTeX2e}
\ProvidesExplPackage
  {polyglossia} {2023/12/11} {v1.66}
  {Modern multilingual typesetting with XeLaTeX and LuaLaTeX}
\RequirePackage{etoolbox}
\RequirePackage{xkeyval}[2008/08/13]
% Will raise error if used with anything else than XeTeX or LuaTeX
\RequirePackage{fontspec}[2010/06/08]% v2.0
\RequirePackage{iftex}

\prg_generate_conditional_variant:Nnn \clist_if_in:Nn {Ne} {TF, T, F} % check if needed

% correct a bug in tracklang
\AddToHook{package/tracklang/after}{%
  \IfPackageAtLeastTF{tracklang}{2019/08/30}
      {}
      {\global\def\AddTrackedLangage{\AddTrackedLanguage}}
}

%% The following is for compatibility with Babel-aware package:
% \languageshorthands is provided by babelsh.def, which is
% only loaded by some glosses, but some classes presuppose
% it is there generally
\ProvideDocumentCommand \languageshorthands { m } {}
\AddToHook{begindocument/before}{
  \cs_gset_eq:NN \bbl@set@language \xpg@set@language@aux  % for biblatex
  \cs_gset_eq:NN \bbl@main@language \xpg@main@language    % for biblatex
  \ProvideDocumentCommand \texorpdfstring { m m } { #1 }  % dummy command if hyperref is not loaded
}

%% when no patterns are available, we use \l@nohyphenation, assigned to 255
%%  (suggestion by Enrico Gregorio)
%% \l@nohyphenation is defined in polyglossia.lua
\sys_if_engine_luatex:TF
  {
	\RequirePackage{luatexbase} % already included by fontspec, but needed here
	\RequireLuaModule{polyglossia}
  }{
	\cs_if_free:cT { l@nohyphenation } 
	   {\chardef\l@nohyphenation=255 }
  }

% Which version of XeTeX do we use? What is the boudary class? 4095 or 255
\cs_if_exist:cTF { e@alloc@intercharclass@top }
  { \let\xpg@boundaryclass=\e@alloc@intercharclass@top }
  { \chardef\xpg@boundaryclass=\@cclv }

% Useful for getting list of loaded languages and variants. Like babel's bbl@loaded
% all language loaded
\seq_new:N \__xpg_langs_loaded
% list of loaded languages (polyglossia name)
\clist_new:N \xpg@loaded
% list of loaded variants
\clist_new:N \xpg@vloaded
% list of loaded languages (babel name)
\clist_new:N \xpg@bloaded
% list of loaded languages (bcp-47 id)
\clist_new:N \xpg@bcp@loaded

% counter in latin
\def\latinalph#1{\expandafter\latin@alph\csname c@#1\endcsname}
\def\latinAlph#1{\expandafter\latin@Alph\csname c@#1\endcsname}

% select language hook
\cs_new_nopar:Nn \xpg_at_begin_document_selectlanguage: {}
% \disablehyphenation hook
\cs_new_nopar:Nn \xpg_at_begin_document_hyphenation: {}

% hook to be executed at begin of document
\cs_new_nopar:Nn \xpg_at_begin_document: {
  % save various command
  \let\latin@alph\@alph   % TODO rename when we have the C locale
  \let\latin@Alph\@Alph   % TODO rename when we have the C locale
  % push to C language gloss
  \let\polyglossia@Clang@@arabic\@arabic
  \let\polyglossia@Clang@arabic\arabic
  
  \xpg@initial@setup
  % apply \familydefault changes
  \xpg@set@familydefault
}

\AddToHook{begindocument}{
  \xpg_at_begin_document:
}

% The following needs to go after any \AtBeginDocument (also of packages
% loaded after \set[main|other]language
\AddToHook{begindocument/end}{
  % now we have the C locale definition: select the language
  \xpg_at_begin_document_selectlanguage:
  % If hyphenation disabling has been requested in preamble, do it now
  \xpg_at_begin_document_hyphenation:
}

%% custom message macros
\providecommand*{\xpg@error}[1]{
   \PackageError{polyglossia}{#1}{}
}

\providecommand*{\xpg@warning}[1]{
   \PackageWarning{polyglossia}{#1}
}

\providecommand*{\xpg@info}[1]{
   \PackageInfo{polyglossia}
   {#1\@gobble}
} %% the \@gobble is to prevent displaying the line nr

%TODO change all instances of \xpg@nopatterns in gloss-*.ldf files
\providecommand*{\xpg@nopatterns@fallback}[2][nohyphenation]{
   \xpg@warning{No~ hyphenation~ patterns~ were~ loaded~ for~ `#2'\MessageBreak
         I~ will~ use~ \string\language=\string\l@ #1\space instead}
   \expandafter\adddialect\csname l@#2\expandafter\endcsname\csname l@#1\endcsname\relax}

\providecommand*{\xpg@nopatterns}[1]{
   \xpg@warning{No~ hyphenation~ patterns~ were~ loaded~ for~ `#1'\MessageBreak
         I~ will~ use~ \string\language=\string\l@nohyphenation\space instead}
   %%TODO? \expandafter\adddialect\csname l@#1\endcsname\l@nohyphenation\relax
   }

\def\xpg@ill@value#1#2{
  \xpg@warning{Illegal~ value~ (#1)~ for~ #2}}

% error out if lang is not loaded
\cs_new_nopar:Nn \polyglossia@error@iflangnotloaded:n
{
  \seq_if_in:NeF \__xpg_langs_loaded {#1}
  {
    \xpg@error{language~ #1~ is~ not~ loaded.~ Please~ load~ it~ before~ using~ it.}
  }
}

\msg_new:nnn { polyglossia } { languagenotloaded }
{
  The~ language~ #1~ is~ not~ loaded.~ You~ should~ load~ it.
}
\msg_redirect_name:nnn { polyglossia } { languagenotloaded } { critical }

\msg_new:nnn { polyglossia } { languagenolongerloaded }
{
  The~ language~ #1~ is~ no~ longer~ loaded.~ Please~ rerun~ LaTeX.
}
\msg_redirect_name:nnn { polyglossia } { languagenolongerloaded } { warning }

% 

%% use macro if defined, else warn that it is not
\cs_new_nopar:Nn \__xpg_use_or_warn:N
{
  \cs_if_exist_use:NF {#1}
  {
    \xpg@warning {  \tl_to_str:N {#1} ~ is~ not~ defined }
  }
}
\cs_generate_variant:Nn \__xpg_use_or_warn:N {c}


%% ensure directionality if bidi is loaded, else ignore
\def\@@ensure@dir#1{\ifcsundef{@ensure@dir}{#1}{\@ensure@dir{#1}}}
\def\@@ensure@maindir#1{\ifcsundef{@ensure@maindir}{#1}{\@ensure@maindir{#1}}}

%% Used by the language definitions files for right-to-left languages
\NewDocumentCommand \RequireBidi {}
  {
    \sys_if_engine_luatex:TF
      {\ifx\@onlypreamble\@notprerr\else\RequirePackage{luabidi}\fi}
      {\ifx\@onlypreamble\@notprerr\else\RequirePackage{bidi}\fi}
  }

% if #1 is LR run #2 else #3
\prg_set_conditional:Nnn \__xpg_if_LR_str:n {p, T, F, TF}
{
  \str_case_e:nnF{#1}{
    {LR}{\prg_return_true:}
    {RL}{\prg_return_false:}
  }
  {
    \xpg@error{Unknown~ direction~#1}
    \prg_return_false:
  }
}
\prg_generate_conditional_variant:Nnn \__xpg_if_LR_str:n {e} {p, T, F, TF}

% (lua)bidi commands to change directionality for paragraphs
% and inline text.
% overwritten with correct package
\cs_new_nopar:Nn{\polyglossia@setpardirection:n}{
  \__xpg_if_LR_str:nF {#1}
  {
    \xpg@error{right-to-left,~ but~ (lua)bidi~ package~ was~ not~ loaded!}
  }
}
\cs_new_nopar:Nn{\polyglossia@settextdirection:n}{
  \__xpg_if_LR_str:nF {#1}
  {
    \xpg@error{right-to-left,~ but~ (lua)bidi~ package~ was~ not~ loaded!}
  }
}
\AddToHook{package/bidi/after}{
  \cs_gset_nopar:Nn{\polyglossia@setpardirection:n}{
    \__xpg_if_LR_str:nTF{#1}
    {
      \setLR
    }
    {
      \setRL
    }
  }
  \cs_gset_nopar:Nn{\polyglossia@settextdirection:n}{
    \__xpg_if_LR_str:nTF{#1}
    {
      \LRE
    }
    {
      \RLE
    }
  }
}
\AddToHook{package/luabidi/after}{
  \cs_gset_nopar:Nn{\polyglossia@setpardirection:n}{
    \__xpg_if_LR_str:nTF{#1}
    {
      \setLR
    }
    {
      \setRL
    }
  }
  \cs_gset_nopar:Nn{\polyglossia@settextdirection:n}{
    \__xpg_if_LR_str:nTF{#1}
    {
      \LRE
    }
    {
      \RLE
    }
  }
}

% emulate \RTLmain
\sys_if_engine_luatex:TF
  { \cs_new_nopar:Nn \__xpg_setRTLmain: { \setRTLmain } }
  { \cs_new_nopar:Nn \__xpg_setRTLmain: { \@RTLmaintrue\setnonlatin } }

%% compatibility with babel
\let\addto\gappto % gappto is defined in etoolbox

%% NEW EXPERIMENTAL SETUP INTERFACE FOR GLOSS FILES
%% options currently available:
%% language : the name of the language (as understood by fontspec)
%% hyphennames : the different hyphenation patterns to try (comma separated list)
%%%   TODO: if pattern is prefixed by !, then it should be loaded as a fallback, with \xpg@nopatterns@fallback - i.e. with a warning: e.g. sanskrit for hindi, or catalan for asturian. – Also for languages with variants!  (English and German, etc.)
%% script : the name of the script (as understood by fontspec) – default is Latin
%% scripttag : the OpenType tag for the script
%% langtag : the OpenType tag for the language
%% hyphenmins : the hyphenmins for this language (comma-sep list of two integers)
%% frenchspacing : boolean
%% indentfirst : boolean
%% fontsetup : boolean
%% TODO: nouppercase : boolean (for scripts like Arabic, Devanagari, etc which have no concept of uppercase/lowercase)
%% TODO: localalph = {<alph_csname>,<Alph_csname>}
%% TODO: localnumeral = <csname>
%%       or even better localdigits = {0123456789} for fully automatic setup
\newcommand*\PolyglossiaSetup[2]{
  \polyglossia@keys_define_lang:n{#1}
  \keys_set:nn { polyglossia / #1 } { #2 }
  \polyglossia_setup_hyphen:n {#1}
  %define booleans etoolbox style and set defaults
  %% TODO ? \providetoggle{#1@setup@done}%
  % we initialize these so that we can use \gappto below
  \csgdef{init@extras@#1}{}
  \csgdef{init@noextras@#1}{} % we don't use this yet: remove?
  % here we do the fontsetup:
  \xpg__auto_setupfont:n { #1 }
  %% TODO? \toggletrue{#1@setup@done}
  % register base alias
  \xpg_language_alias { #1 } { #1 }
}

% Adjust language key setting after initial setup.
% Principally any key can be altered this way.
% The command is mainly used in gloss file where
% different options (variant, script, etc.) result
% in different babel names, bcp47 specification,
% or OpenType language or script tags.
\DeclareDocumentCommand \SetLanguageKeys { m m }
{
  \clist_map_inline:nn { #1 } { \keys_set:nn { polyglossia / ##1 } { #2 } }
}


% setup hyphennames from a str list of hyphen
\cs_new:Nn \polyglossia_setup_hyphen:n {
  \clist_set:Ne{\l_tmpa_clist}{\prop_item:Nn \polyglossia@langsetup {#1 / hyphennames}}
  \providebool{havehyphen}
  \boolfalse{havehyphen}
  % for each hyphen in the set until we find one that works
  \clist_map_inline:Nn \l_tmpa_clist {
    \ifbool{havehyphen}{}{
       % check if language hyphenname is defined
      \__xpg_check_if_exist_l@:nF{#1}{
          % if not, first consider nohyphenation
          \str_if_eq:nnTF{##1}{nohyphenation}
            {
               \cs_gset_eq:cc{l@#1}{l@##1}
               \global\booltrue{havehyphen}
            }{
               % then test if hyphenation is defined
               \xpg@ifdefined{##1}{
                  % test if language hyphenation is nohyphenation
                  \cs_if_eq:cNF{l@#1}{\l@nohyphenation}{\global\booltrue{havehyphen}}{%
                      % if false define language to hyphenation if it is not equal...
                      \str_if_eq:nnF{#1}{##1}{\cs_gset_eq:cc{l@#1}{l@##1}}
                      % ...and load
                      \xpg@set@hyphenation@patterns{##1}
                      \global\booltrue{havehyphen}
                  }
                }{}
           }
       }
    }
  }
  % if l@#1 does not yet exist,
  % we assign it to nohyphenation
  % we do this here in case and if the hyphennames key was omitted
  \ifbool{havehyphen}{}{
    \xpg@ifdefined{#1}{}
    {
      \xpg@nopatterns{#1}
      \expandafter\adddialect\csname l@#1\endcsname\l@nohyphenation\relax
    }
  }
  \csdef{#1@language}{
    \polyglossia@setup@language@patterns{#1}
  }
  % setup hyphenmins
  \clist_set:Ne \l_tmpa_clist
    { \prop_item:Nn \polyglossia@langsetup {#1 / hyphenmins} }
  \cs_if_eq:cNF {l@#1} \l@nohyphenation
    {
      \use:x
        {
          \exp_not:N \setlocalhyphenmins {#1}
            { \clist_item:Nn \l_tmpa_clist {1} }
            { \clist_item:Nn \l_tmpa_clist {2} }
        }
    }
}

\newcommand*\polyglossia@setup@language@patterns[1]{
  \ifbool{xpg@hyphenation@disabled}{
    \xdef\xpg@lastlanguage{\the\csname l@#1\endcsname}
  }{
    % first, test if \l@#1 exists
    % without that, \csname l@#1\endcsname will be defined as \relax
    \cs_if_exist:cTF {l@#1}
      {
        \cs_if_eq:cNTF {l@#1} \l@nohyphenation
          {
            \language=\l@nohyphenation
          }
          {
            \xpg@set@hyphenation@patterns{#1}
          }
      }
      {
        % Since this function is sometimes called from the gloss files
        % directly, we need to check whether the requested hyphenname exists.
        \xpg@ifdefined{#1}{}
        {
          \xpg@nopatterns{#1}
          \expandafter\adddialect\csname l@#1\endcsname\l@nohyphenation\relax%
        }
        \xpg@set@hyphenation@patterns{#1}
      }
  }
}

\prop_new:N \polyglossia@langsetup

\cs_new_protected:Npn \polyglossia@keys_define_lang:n #1 {
  \keys_define:nn {polyglossia}{
    % the script font
    #1 / script
       .code:n = {
          \prop_gput:Nnn{\polyglossia@langsetup}{#1/script}{##1}
          \prop_gput:Nne{\polyglossia@langsetup}{#1/lcscript}
               {\tl_if_empty:nF{##1}{\str_lowercase:n{##1}}}
    },
    #1 / script
       .value_required:n = true,
    #1 / script
       .initial:n = latin,
    % the opentype script tag
    #1 / scripttag
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/scripttag}{##1}},
    #1 / scripttag
       .default:n = {},
    #1 / scripttag
      .initial:n = {},
    % the language full name
    #1 / language
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/language}{##1}},
    #1 / language
       .value_required:n = true,
    #1 / language
        .initial:x = {\str_uppercase:n#1},
    % the language tag
    #1 / langtag
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/langtag}{##1}},
    #1 / langtag
       .value_required:n = true,
    #1 / langtag
       .initial:n = {},
    % the BCP-47 tag
    #1 / bcp47
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/bcp47}{##1}},
    #1 / bcp47
       .value_required:n = true,
    #1 / bcp47
       .initial:n = {},
    % the BCP-47 language tag
    #1 / bcp47-language
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/bcp47-language}{##1}},
    #1 / bcp47-language
       .value_required:n = true,
    #1 / bcp47-language
       .initial:n = {},
    % the BCP-47 region tag
    #1 / bcp47-region
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/bcp47-region}{##1}},
    #1 / bcp47-region
       .value_required:n = false,
    #1 / bcp47-region
       .initial:n = {},
    % the BCP-47 script tag
    #1 / bcp47-script
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/bcp47-script}{##1}},
    #1 / bcp47-script
       .value_required:n = true,
    #1 / bcp47-script
       .initial:n = {},
    % the BCP-47 variant tag
    #1 / bcp47-variant
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/bcp47-variant}{##1}},
    #1 / bcp47-variant
       .value_required:n = false,
    #1 / bcp47-variant
       .initial:n = {},
    % the BCP-47 extension-t tag
    #1 / bcp47-extension-t
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/bcp47-extension-t}{##1}},
    #1 / bcp47-extension-t
       .value_required:n = false,
    #1 / bcp47-extension-t
       .initial:n = {},
    % the BCP-47 extension-u tag
    #1 / bcp47-extension-u
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/bcp47-extension-u}{##1}},
    #1 / bcp47-extension-u
       .value_required:n = false,
    #1 / bcp47-extension-u
       .initial:n = {},
    % the BCP-47 extension-x tag
    #1 / bcp47-extension-x
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/bcp47-extension-x}{##1}},
    #1 / bcp47-extension-x
       .value_required:n = false,
    #1 / bcp47-extension-x
       .initial:n = {},
    % the BCP-47 casing alias
    #1 / bcp47-casing
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/bcp47-casing}{##1}},
    #1 / bcp47-casing
       .value_required:n = false,
    #1 / bcp47-casing
       .initial:n = {},
    % hyphennames
    #1 / hyphennames
    .code:n = {
      \clist_set:Nn{\l_tmpa_clist}{##1}
      \prop_gput:Nne{\polyglossia@langsetup}{#1/hyphennames}{\clist_use:Nn \l_tmpa_clist {,}}
    },
    #1 / hyphennames
       .value_required:n = true,
    #1 / hyphennames
      .initial:x = {\c_empty_clist},
    % direction
    #1 / direction
    .  code:n = {
           \str_case_e:nnTF{##1}{
             {LR}{}
             {RL}{\RequireBidi}
           }
           {\prop_gput:Nnn{\polyglossia@langsetup}{#1/direction}{##1}}
           {\xpg@error{Unknown~ direction~ "##1"~ for~ language~ "#1"}}
       },
    #1 / direction
      .value_required:n = true,
    #1 / direction
      .initial:n = {LR},
    % minimal left and right hyphenation minima using
    #1 / hyphenmins
    .code:n = {
      % check syntax
      \int_compare:nNnF { \clist_count:n {##1} } = {2}
        {\xpg@error{hypenmins~should~be~a~list~of~two~entries,~got~"##1"}}
      % set prop
      \prop_gput:Nnn \polyglossia@langsetup {#1/hyphenmins} {##1}
    },
    #1 / hyphenmins
      .value_required:n = true,
    #1 / hyphenmins
     .initial:n = {2,3},
    % minimal length for hyphenation (LuaTeX only)
    #1 / totalhyphenmin
    .code:n = {
      % check syntax
      \int_compare:nNnF { \clist_count:n {##1} } = {1}
        {\xpg@error{totalhyphenhypenmin~should~be~a~single~entry,~got~"##1"}}
      % set prop
      \prop_gput:Nnn \polyglossia@langsetup {#1/totalhyphenmin} {##1}
    },
    #1 / totalhyphenmin
      .value_required:n = false,
    % frenchspacing
    #1 / frenchspacing  .bool_gset:c = g__xpg_#1_fs_bool ,
    #1 / frenchspacing  .default:n = true ,
    #1 / frenchspacing  .initial:n = false ,
    % indent first line
    #1 / indentfirst  .bool_gset:c = g__xpg_#1_if_bool ,
    #1 / indentfirst  .default:n = true ,
    #1 / indentfirst  .initial:n = false ,
    % fontsetup
    #1 / fontsetup  .bool_gset:c = g__xpg_#1_fontsetup_bool ,
    #1 / fontsetup  .default:n = true ,
    #1 / fontsetup  .initial:n = false ,
    % environment name
    #1 / envname
       .code:n = {
           \prop_gput:Nnn{\polyglossia@langsetup}{#1/envname}{##1}
       },
    #1/ envname.value_required:n = true,
    #1/ envname.initial:n = {#1},
    % babel name
    #1 / babelname
       .code:n = {
           \prop_gput:Nnn{\polyglossia@langsetup}{#1/babelname}{##1}
       },
    #1/ babelname.value_required:n = true,
    #1/ babelname.initial:n = {#1},
    % default numerals
    #1 / localnumeral
         . code:n =  {
            \prop_gput:Nnn{\polyglossia@langsetup}{#1/localnumeral}{##1}
            \prop_gput:Nnn{\polyglossia@langsetup}{#1/Localnumeral}{##1}
         },
    #1 / localnumeral.value_required:n = true,
    #1 / localnumeral.initial:n = {polyglossia@C@localnumeral},
    % uppercased
    #1 / Localnumeral
         . code:n =  {
            \prop_gput:Nnn{\polyglossia@langsetup}{#1/Localnumeral}{##1}
         },
    #1 / Localnumeral.value_required:n = true,
    #1 / Localnumeral.initial:n = {polyglossia@C@localnumeral},
    % environment define command (by default create the environment)
    #1 / DefineCommandsCmd
       .code:n = {\prop_gput:Nnn{\polyglossia@langsetup}{#1/DefineCommandsCmd}{##1}},
    #1 / DefineCommandsCmd
       .value_required:n = true,
    #1 / DefineCommandsCmd
      .initial:n = {xpg_define_language_commands:e}
  }
}

% TODO move to C module
\newcommand*{\polyglossia@C@localnumeral}[2]{
   \polyglossia@Clang@@arabic{#2}
}

\tl_new:N \l__xpg_localnumeral_tl
\bool_new:N \l__xpg_localnumeral_bool

\keys_define:nn { polyglossia / localnumeral }
  {
	lang .choice:, 
	lang / main .code:n =  \tl_set:Nn \l__xpg_localnumeral_tl { \mainlanguagename } ,
	lang / local .code:n = \tl_set:Nn \l__xpg_localnumeral_tl { \languagename } 
							\bool_set_true:N \l__xpg_localnumeral_bool ,
	lang / unknown .code:n = \tl_set:Nn \l__xpg_localnumeral_tl { #1 } ,
  }
  
\cs_new:Npn \__xpg_localnumeral:nnn #1 #2 #3
  {
	\group_begin:
	\keys_set:ne { polyglossia / localnumeral } { #2 }
	\bool_if:NF \l__xpg_localnumeral_bool { \foreignlanguage { \l__xpg_localnumeral_tl } }
	  { \use:c { \prop_item:Ne \polyglossia@langsetup
	  { \l__xpg_localnumeral_tl / #3 } } { } { #1 } }
	\group_end:
  }

\NewDocumentCommand \localnumeral { s ={ lang } O{ local } m }
  {
    \IfBooleanTF { #1 }
	  {
		\exp_args:Nc \__xpg_localnumeral:nnn { c@#3 } { #2 } { localnumeral }
	  }
	  {
		\__xpg_localnumeral:nnn { #3 } { #2 } { localnumeral }
	  }
  }

\NewDocumentCommand \Localnumeral { s ={ lang } O{ local } m }
  {
    \IfBooleanTF { #1 }
	  {
		\exp_args:Nc \__xpg_localnumeral:nnn { c@#3 } { #2 } { Localnumeral }
	  }
	  {
		\__xpg_localnumeral:nnn { #3 } { #2 } { Localnumeral }
	  }
  }

\cs_new_nopar:Npn \xpg__french_spacing:n #1
  { 
    \bool_if:cTF { g__xpg_#1_fs_bool } 
	{ \frenchspacing } { \nonfrenchspacing }
  }

\cs_new_nopar:Npn \xpg__indent_first:n #1
  {
	\bool_if:cTF { g__xpg_#1_if_bool }
	{ \french@indent } { \nofrench@indent }
  }

\cs_new:Nn{\polyglossia@lang@setpardirection:n}{
  \prop_get:NeNTF \polyglossia@langsetup {#1/direction} \l_tmpa_tl
      {
        \polyglossia@setpardirection:n{\l_tmpa_tl}
      }
      {
        \xpg@error{Could~ not~ retrieve~ key~ direction~ for~ language~ "#1"}
        \prop_show:N{\polyglossia@langsetup}
      }
}


\cs_new:Nn{\polyglossia@lang@settextdirection:nn}{
  \prop_get:NeNTF \polyglossia@langsetup {#1/direction} \l_tmpa_tl
      {
        \polyglossia@settextdirection:n{\l_tmpa_tl}{#2}
      }
      {
        \xpg@error{Could~ not~ retrieve~ key~ direction~ for~ language~ "#1"}
        \prop_show:N{\polyglossia@langsetup}
      }
}

\def\xpg@lastlanguage{0}

\providebool{xpg@hyphenation@disabled}
\boolfalse{xpg@hyphenation@disabled}

\def\xpg@disablehyphenation{
  \ifx\@onlypreamble\@notprerr
     \xpg@@disablehyphenation
  \else
     % if this is used in the preamble, we have to postpone
     % the execution until the main language has been set (#125).
     \cs_gset_nopar:Nn \xpg_at_begin_document_hyphenation: {
        \xpg@@disablehyphenation
     }
  \fi
}

\def\xpg@@disablehyphenation{
  \ifbool{xpg@hyphenation@disabled}{}{
    \booltrue{xpg@hyphenation@disabled}
    \xdef\xpg@lastlanguage{\the\language}
    % We do not call \xpg@set@hyphenation@patterns here to avoid a warning message.
    % "nohyphenation" is not listed in language.dat.lua.
    \language=\l@nohyphenation
  }
}

\def\xpg@enablehyphenation{
  \ifbool{xpg@hyphenation@disabled}{
    \boolfalse{xpg@hyphenation@disabled}
    \language=\csname xpg@lastlanguage\endcsname
  }{}%
}

\let\disablehyphenation\xpg@disablehyphenation
\let\enablehyphenation\xpg@enablehyphenation

\cs_new:Npn \xpg__auto_setupfont:n #1 {
  \bool_if:cTF { g__xpg_#1_fontsetup_bool }
  {
    \str_if_eq:eeTF{\prop_item:Nn{\polyglossia@langsetup}{#1/lcscript}}{latin}
         {\xpg@fontsetup@latin{#1}}
         {\xpg@fontsetup@nonlatin{#1}}
  }
  {
    \xpg@info{Skipping~ automatic~ font~ setup~ for~ language~ #1}
  }
}


% add fontfeature Language=#2 to langtag #1
% do nothing if #1 or #2 is empty
\cs_new:Nn \polyglossia@addfontfeature@language:nn {
  \bool_if:nTF{\tl_if_empty_p:n{#1} || \tl_if_empty_p:n{#2}}
  {
    % maybe an error ?
    \xpg@warning{Asking~ to~ add~ empty~ feature~to~ main~ font~
      (Language="#2"~ to~ langtag~ "#1")}
  }
  {
    \str_if_eq:nnTF{#2}{Turkish}{
      \fontspec_if_language:nTF {TRK}
      {
        \addfontfeature{Language=Turkish}
      }
      {
        \fontspec_if_language:nTF {TUR}
        {
          \addfontfeature{Language=Turkish}
        }{}
      }
    }{
      \fontspec_if_language:nTF{#1}
      {
        \addfontfeature{Language=#2}
      }
      {}
    }
  }
}
\cs_generate_variant:Nn  \polyglossia@addfontfeature@language:nn { on , no, oo , Vn, nV, VV , xn, nx, xx}

% add fontfeature Script=#2 to scripttag #1
% do nothing if #1 or #2 is empty
\cs_new:Nn \polyglossia@addfontfeature@script:nnn {
  \bool_if:nTF{\tl_if_empty_p:n{#2} || \tl_if_empty_p:n{#3}}
  {
    % maybe an error ?
    \xpg@warning{Asking~ to~ add~ empty~ feature~to~ main~ font
                 (Script="#3"~ to~ scripttag~ "#2")}
  }
  {
    \fontspec_if_script:nTF{#2}
       {\addfontfeature{Script=#3}}
       {
        \tl_set:Nn \xpg_ffamily_tl {}
        \tl_set:Nn \xpg_ffamilysh_tl { #1 }
        \str_if_eq:nnT { #1 } { rm }
           {
             \tl_set:Nn \xpg_ffamily_tl { roman }
             \tl_set:Nn \xpg_ffamilysh_tl {}
           }
        \str_if_eq:nnT { #1 } { sf }
           {
             \tl_set:Nn \xpg_ffamily_tl { sans~ serif }
           }
        \str_if_eq:nnT { #1 } { tt }
           {
             \tl_set:Nn \xpg_ffamily_tl { monospace }
           }
        % Strip font family name for error message
        % Courtesy of egreg, https://tex.stackexchange.com/a/613996
        \str_set:Nx \xpg_fname_str { \fontname\font }
        % Remove all after :
        \regex_replace_once:nnN { \:.* } { } \xpg_fname_str
        % ... and all after /
        \regex_replace_once:nnN { /.* } { } \xpg_fname_str
        % ... and brackets
        \regex_replace_once:nnN { \[ } { } \xpg_fname_str
        \regex_replace_once:nnN { \] } { } \xpg_fname_str
        % ... and extensions
        \regex_replace_once:nnN { \.[^\.]* \Z } { } \xpg_fname_str
        % ... and, finally, quotation marks
        \regex_replace_once:nnN { " } { } \xpg_fname_str
        \xpg@error{
          The~ current~ main ~ \xpg_ffamily_tl\space font,~ \xpg_fname_str,~ does~ not~ contain~ the~"#3"~ script!\MessageBreak
          Please~ define~\csname\tl_if_empty:nF{#3}{\str_lowercase:n{#3}}font\xpg_ffamilysh_tl\endcsname~
          with~ \string\newfontfamily\space command
          }
        }
  }
}
\cs_generate_variant:Nn  \polyglossia@addfontfeature@script:nnn { non , nno, noo , nVn, nnV, nVV , nxn, nnx, nxx}

\def\xpg@fontsetup@latin#1{
  \begingroup
  \csgdef{#1@font@rm}{
    \cs_if_exist_use:cF{#1font}{
      \rmfamilylatin
      \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
    }
  }
  \csgdef{#1@font@sf}{
    \cs_if_exist_use:cF{#1fontsf}{
      \sffamilylatin
      \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
    }
  }
  \csgdef{#1@font@tt}{
    \cs_if_exist_use:cF{#1fonttt}{
      \ttfamilylatin
      \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
    }
  }
  \endgroup
}

\def\xpg@fontsetup@nonlatin#1{
  \begingroup
  \csgdef{#1@font@rm}{
    \cs_if_exist_use:cF{#1font}
      {
       \providetoggle{#1@use@script@font}
       \str_if_eq:nnTF{\prop_item:Nn{\polyglossia@langsetup}{#1/script}}{\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
        {\rmfamilylatin}
        {\cs_if_exist_use:cTF{\prop_item:Nn{\polyglossia@langsetup}{#1/lcscript} font}
          {
             \toggletrue{#1@use@script@font}
           }
           {
             \rmfamilylatin
           }
       }
       \iftoggle{#1@use@script@font}{}{
           \polyglossia@addfontfeature@script:nxx{rm}
                                                 {\prop_item:Nn{\polyglossia@langsetup}{#1/scripttag}}
                                                 {\prop_item:Nn{\polyglossia@langsetup}{#1/script}}
       }%
       \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
      }%
      \def\familytype{rm}
  }%
  \csgdef{#1@font@sf}{
    \cs_if_exist_use:cF{#1fontsf}
      {
       \providetoggle{#1@use@script@fontsf}
       \str_if_eq:nnTF{\prop_item:Nn{\polyglossia@langsetup}{#1/script}}{\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
        {\sffamilylatin}
        {\cs_if_exist_use:cTF{\prop_item:Nn{\polyglossia@langsetup}{#1/lcscript} fontsf}
          {
             \toggletrue{#1@use@script@fontsf}
           }
           {
             \sffamilylatin
           }
       }
       \iftoggle{#1@use@script@fontsf}{}{
           \polyglossia@addfontfeature@script:nxx{sf}
                                                 {\prop_item:Nn{\polyglossia@langsetup}{#1/scripttag}}
                                                 {\prop_item:Nn{\polyglossia@langsetup}{#1/script}}
       }%
       \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
      }%
      \def\familytype{sf}
  }%
  \csgdef{#1@font@tt}{
    \cs_if_exist_use:cF{#1fonttt}
      {
       \providetoggle{#1@use@script@fonttt}
       \str_if_eq:nnTF{\prop_item:Nn{\polyglossia@langsetup}{#1/script}}{\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
       {\ttfamilylatin}
       {\cs_if_exist_use:cTF{\prop_item:Nn{\polyglossia@langsetup}{#1/lcscript} fonttt}
           {
             \toggletrue{#1@use@script@fonttt}
           }
           {
             \ttfamilylatin
           }
       }
       \iftoggle{#1@use@script@fonttt}{}{
           \polyglossia@addfontfeature@script:nxx{tt}
                                                 {\prop_item:Nn{\polyglossia@langsetup}{#1/scripttag}}
                                                 {\prop_item:Nn{\polyglossia@langsetup}{#1/script}}
       }
       \polyglossia@addfontfeature@language:xx{\prop_item:Nn{\polyglossia@langsetup}{#1/langtag}}
                                              {\prop_item:Nn{\polyglossia@langsetup}{#1/language}}
      }
      \def\familytype{tt}
  }
  \endgroup
}

%%% END OF PolyglossiaSetup

%% ensure localization of \markright and \markboth commands
%%% THIS IS NOW DISABLED BY DEFAULT
\cs_new_nopar:Nn \polyglossia@local@marks:n { }
\cs_new_nopar:Nn \polyglossia@enable@local@marks:
{
  \xpg@info{Option:~ localmarks}
  \cs_gset_nopar:Nn \polyglossia@local@marks:n
  {
	 \def\xpg@tmp@lang{##1}
	 \DeclareRobustCommand\markboth[2]{
		\begingroup
		   \let\label\relax \let\index\relax \let\glossary\relax
		   \unrestored@protected@xdef\@themark
		   {
			{\lowercase{\foreignlanguage{\xpg@tmp@lang}}{\protect\@@ensure@maindir{####1}}}
			{\lowercase{\foreignlanguage{\xpg@tmp@lang}}{\protect\@@ensure@maindir{####2}}}
		   }
		   \@temptokena \expandafter{\@themark}
		   \mark{\the\@temptokena}
		\endgroup
		\if@nobreak\ifvmode\nobreak\fi\fi
	 }
	 \DeclareRobustCommand\markright[1]{
		\begingroup
		   \let\label\relax \let\index\relax \let\glossary\relax
		   \expandafter\@markright\@themark
		   {\lowercase{\foreignlanguage{\xpg@tmp@lang}}{\protect\@@ensure@maindir{####1}}}
		   \@temptokena \expandafter{\@themark}
		   \mark{\the\@temptokena}
		\endgroup
		\if@nobreak\ifvmode\nobreak\fi\fi
	 }
  }
}

%we call this macro when a gloss file is not found for a given language
\def\xpg@nogloss#1{
   \xpg@warning{File~ gloss-#1.ldf~ do~ not~  exists!\MessageBreak
   I~ will~ nevertheless~ try~ to~ use~ hyphenation~ patterns~ for~ #1.}
  \PolyglossiaSetup{#1}{hyphenmins={2,3},hyphennames={#1},fontsetup=true}
  % the above amounts to:
  %\ifcsundef{l@#1}%
  %  {\expandafter\adddialect\csname l@#1\endcsname\l@nohyphenation\relax}%
  %  {\setlocalhyphenmins{#1}{2}{3}}%
  %\csdef{#1@language}{\language=\csname l@#1\endcsname}%
}

\newcommand{\xpg@input}[1]{
  % Store catcode of @ before making at letter
  \chardef\xpg@saved@at@catcode\catcode`\@
  \makeatletter
  \input{#1}
  % restore former @ catcode
  \catcode`\@=\xpg@saved@at@catcode
}

% try to load a language file
\cs_new:Nn \polyglossia_load_lang_definition:nn {
	\file_if_exist:nTF{gloss-#2.ldf}
	{
	  % Temporarily force catcode of ~ to 13 since babelsh.def
	  % requires it. This is needed particularly with LaTeX3
	  % packages which force \ExplSyntaxOn (#425)
	  \protected\edef\xpg@restore@tilde@catcode{\catcode 126 = \the\catcode 126\relax}
	  \catcode 126 = 13
	  \xpg@input{gloss-#2.ldf}
	  \setkeys{#2}{#1}
	  % restore former ~ catcode
	  \xpg@restore@tilde@catcode
	}
	{
	  \xpg@nogloss{#2}
	}
}
\cs_generate_variant:Nn \polyglossia_load_lang_definition:nn { ee }

% load a master language from an alias file
\newcommand*\xpg@load@master@language[1] {
  \xpg@input{gloss-#1.ldf}
  \seq_if_in:NeF \__xpg_langs_loaded {#1}
  {
    % define environment and command if not alias
    \str_if_eq:eeT {\prop_item:Ne \__xpg_alias {#1/target}} {#1} {
      \use:c{\prop_item:Nn{\polyglossia@langsetup}
                          {#1/DefineCommandsCmd}}
                          {#1}
      }
  }
  \polyglossia@register@language:nn{}{#1}
  \seq_gput_right:Nn \__xpg_langs_loaded {#1}
}

\prop_new:N \__xpg_alias

% define environment and command if not alias
\cs_new:Nn \xpg_define_language_commands:n {
  \str_if_eq:eeT {\prop_item:Ne \__xpg_alias {#1/target}} {#1}
  {
    \exp_args:Ne
    \NewDocumentEnvironment {\prop_item:Nn{\polyglossia@langsetup}{#1/envname}} { O{} }
    {
      \otherlanguage [ ##1 ] { #1 }
    }
    {
      \endotherlanguage
    }
    \exp_args:Nc \NewDocumentCommand {text#1} { O{} m }
    {
      \__xpg_textlanguage:een{##1}{#1}{##2}
    }
  }
}
\cs_generate_variant:Nn \xpg_define_language_commands:n {e}


% resolve alias property #1 lang #2 item
\cs_new:Nn \xpg_alias_prop_item:nn {
  \prop_if_in:NeTF \__xpg_alias {#1/#2}
  {
    \prop_item:Ne \__xpg_alias {#1/#2}
  }
  {
    \prop_if_in:NeTF \__xpg_alias {#1/target}
    {
      % target to self fall back to language table
      \str_if_eq:eeTF { \prop_item:Ne \__xpg_alias {#1/target} } { #1 }
      {
        \prop_item:Nn{\polyglossia@langsetup} {#1/#2}
      }
      % load alias by recursion
      {
        \xpg_alias_prop_item:ee { \prop_item:Ne \__xpg_alias {#1/target} } {#2}
      }
    }
    {
      % empty
    }
  }
}
\cs_generate_variant:Nn \xpg_alias_prop_item:nn {en, ne, ee}

% add option #2 to list of option of language #1
\cs_new:Nn \xpg_alias_add_to_option_i:nn
{
  \tl_if_blank:eTF {#2}
  {
    \xpg_alias_prop_item:nn {#1}{options}
  }
  {
    \tl_if_blank:eTF { \xpg_alias_prop_item:nn {#1}{options} }
    {
      #2
    }
    {
      \xpg_alias_prop_item:nn {#1}{options},#2
    }
  }
}


% get base language
\cs_new:Nn \xpg_alias_base_lang:n
  {
    \prop_item:Ne \__xpg_alias {#1/target}
  }
\cs_generate_variant:Nn \xpg_alias_base_lang:n {e}

\keys_define:nn { polyglossia/alias }
{
  % babelname\l_tmpa_prop
  babelname .prop_put:N = \__xpg_language_alias_prop,
  % bcp47
  bcp47 .prop_put:N = \__xpg_language_alias_prop,
  % variant
  variant .prop_put:N = \__xpg_language_alias_prop,
}



% provide way to define alias environment and command
% #1 () variant
% #2 [] option (not yet without variant and bcp47 name)
% #3 language
% #4 () babel name
% #5 [] bcp47 name
% #6 alias
\DeclareDocumentCommand \xpg_language_alias { D(){} O{} m D(){} O{} m}
{
  \prop_gremove:Nn \__xpg_alias {#6/target}
  \prop_gremove:Nn \__xpg_alias {#6/options}
  \prop_gremove:Nn \__xpg_alias {#6/bcp47}
  \prop_gremove:Nn \__xpg_alias {#6/babelname}
  \prop_gremove:Nn \__xpg_alias {#6/variant}
  \prop_gput:Nee \__xpg_alias {#6/target} {#3}
  \tl_if_blank:eF {#1}
  {
    \prop_gput:Nee \__xpg_alias {#6/variant} {#1}
  }
  \tl_if_blank:eF {#5}
  {
    \prop_gput:Nee \__xpg_alias {#6/bcp47} {#5}
  }
  \tl_if_blank:eF {#4}
  {
    \prop_gput:Nee \__xpg_alias {#6/babelname} {#1}
  }
  \tl_if_blank:eF {#2}
  {
    \prop_gput:Nee \__xpg_alias {#6/options} {#2}
  }
}


% provide way to define alias environment and command
% \setlanguagealias[<options>]{<language>}{<alias>}
\DeclareDocumentCommand \setlanguagealias {s O{} m m}
{
  % The starred version does not define commands and environments
  \IfBooleanF {#1}
  {
    \exp_args:Nc \DeclareDocumentCommand {text#4} { O{} m }
      {
        \__xpg_textlanguage:een {##1} {#4} {##2}
      }
    \DeclareDocumentEnvironment { #4 } { }
      {
        \otherlanguage { #4 }
      }
      {
        \endotherlanguage
      }
  }
  \tl_clear_new:N \__xpg_alias_option_tl
  \prop_clear_new:N \__xpg_language_alias_prop
  \keys_set_known:nnN{polyglossia/alias} {#2} \__xpg_alias_option_tl
  \xpg_language_alias
    (\prop_item:Nn \__xpg_language_alias_prop {variant})
    % TODO not yet [\__xpg_alias_option_tl]
    [#2]
    {#3}
    (\prop_item:Nn \__xpg_language_alias_prop {babelname})
    [\prop_item:Nn \__xpg_language_alias_prop {bcp47}]
    {#4}
}

\cs_new:Nn \polyglossia@register@language:nn {
  \clist_if_in:NeF \xpg@loaded {#2}{
    \clist_gput_right:Ne \xpg@loaded {#2}
  }
  % Register the language options
  \polyglossia@set@lang@options:nnn {#2} {#1} {@xpg@set@langvariant}
  % register babelname
  \prop_get:NeN \polyglossia@langsetup {#2/babelname} \l_tmpa_tl
  \clist_if_in:NeF \xpg@bloaded {\l_tmpa_tl}{
    \clist_gput_right:Ne \xpg@bloaded {\l_tmpa_tl}
  }
  % register BCP-47 ID
  \prop_get:NeN \polyglossia@langsetup {#2/bcp47} \l_tmpa_tl
  \clist_if_in:NeF \xpg@bcp@loaded {\l_tmpa_tl}{
    \clist_gput_right:Ne \xpg@bcp@loaded {\l_tmpa_tl}
  }
}

\DeclareDocumentCommand \setdefaultlanguage { O{} m }
{
  % latex is an internal language, so do not record
  \str_if_eq:eeF{#2}{latex}
  {
    \clist_if_in:NeF \xpg@loaded {\xpg_alias_base_lang:n{##2}}{
      \clist_gput_right:Ne \xpg@loaded {\xpg_alias_base_lang:n{##2}}
    }
  }
  \seq_if_in:NeF \__xpg_langs_loaded {#2}
  {
    \polyglossia_load_lang_definition:nn{#1}{#2}
    % define environment and command if not alias
    \str_if_eq:eeT {\prop_item:Ne \__xpg_alias {#2/target}} {#2} {
       \use:c{\prop_item:Ne{\polyglossia@langsetup}
            {#2/DefineCommandsCmd}}
            {#2}
    }
    \seq_gput_right:Ne \__xpg_langs_loaded {#2}
  }
   \exp_args:Nee \polyglossia@set@default@language:nn {\xpg_alias_add_to_option_i:nn{#2}{#1}}
    {\xpg_alias_base_lang:n{#2}}
}


\cs_new:Nn \polyglossia@set@default@language:nn
{
  \gdef\xpg@main@language{#2}
  \tl_if_blank:nTF {#1}
  {
    \cs_gset_nopar:Npn \mainlanguagevariant {}
  }
  {
     % Register the language options
     \polyglossia@set@lang@options:nnn {#2} {#1} {@xpg@main@langvariant}
  }
  \csgdef{#2@gvar}{\mainlanguagevariant}
  %% The following settings are for the default language and script
  % this tells bidi.sty or luabidi.sty that the document is RTL
  \__xpg_if_LR_str:eF{\prop_item:Nn{\polyglossia@langsetup}{#2/direction}}
  {
    \__xpg_setRTLmain:
  }
  \cs_gset_nopar:Nn \xpg_at_begin_document_selectlanguage: {
    \selectbackgroundlanguage{#2}
    \selectlanguage[#1]{#2}%
  }
  \xpg@info{Default~ language~ is~ #2}
  \polyglossia@set@language@name[#1]{#2}

  \cs_gset_nopar:Npn \mainlanguagename {#2}
  % Store babelname of main language (for external packages such as biblatex)
  \cs_gset_nopar:Npe \mainbabelname { \prop_item:Nn  \polyglossia@langsetup {#2/babelname} }
  % Store babelname of current language (for external packages such as biblatex)
  \cs_gset_eq:NN \babelname \mainbabelname
  \cs_gset_eq:cc{#2@gbabelname}{babelname}%
  % Store BCP-47 ID and subtags of main language:
  % 1. store main.* (sub)tags
  \cs_gset_nopar:cpe {bcp47.main.tag} { \prop_item:Nn  \polyglossia@langsetup { #2 / bcp47 } }
  \cs_gset_nopar:cpe {bcp47.main.language} { \prop_item:Nn  \polyglossia@langsetup { #2 / bcp47-language } }
  \cs_gset_nopar:cpe {bcp47.main.region} { \prop_item:Nn  \polyglossia@langsetup { #2 / bcp47-region } }
  \cs_gset_nopar:cpe {bcp47.main.script} { \prop_item:Nn  \polyglossia@langsetup { #2 / bcp47-script } }
  \cs_gset_nopar:cpe {bcp47.main.variant} { \prop_item:Nn  \polyglossia@langsetup { #2 / bcp47-variant } }
  \cs_gset_nopar:cpe {bcp47.main.extension.t} { \prop_item:Nn  \polyglossia@langsetup { #2 / bcp47extension-t } }
  \cs_gset_nopar:cpe {bcp47.main.extension.u} { \prop_item:Nn  \polyglossia@langsetup { #2 / bcp47-extension-u } }
  \cs_gset_nopar:cpe {bcp47.main.extension.x} { \prop_item:Nn  \polyglossia@langsetup { #2 / bcp47-extension-x } }
  % For casing, we fall back to language if bcp47-casing is not explicitly set
  \cs_set_nopar:cpx {tmpcasing} { \prop_item:Ne \polyglossia@langsetup { #2 / bcp47-casing } }
  \str_if_empty:NTF \tmpcasing
           { \cs_gset_nopar:cpe {bcp47.main.casing} { \prop_item:Nn  \polyglossia@langsetup {#2 / bcp47-language} } }
           { \cs_gset_nopar:cpe {bcp47.main.casing} { \tmpcasing } }
  % 2. Store lang (sub)tags
  \cs_gset_eq:cc {bcp47.tag} {bcp47.main.tag}
  \cs_gset_eq:cc {bcp47.language} {bcp47.main.language}
  \cs_gset_eq:cc {bcp47.region} {bcp47.main.region}
  \cs_gset_eq:cc {bcp47.script} {bcp47.main.script}
  \cs_gset_eq:cc {bcp47.variant} {bcp47.main.variant}
  \cs_gset_eq:cc {bcp47.extension.t} {bcp47.main.extension.t}
  \cs_gset_eq:cc {bcp47.extension.u} {bcp47.main.extension.u}
  \cs_gset_eq:cc {bcp47.extension.x} {bcp47.main.extension.x}
  \cs_gset_eq:cc {bcp47.casing} {bcp47.main.casing}
  % 3. Store global language BCP47 settings (with default subtags as set by main language options)
  \cs_gset_eq:cc{#2@g.bcp47.tag}{bcp47.tag}
  \cs_gset_eq:cc{#2@g.bcp47.language}{bcp47.language}
  \cs_gset_eq:cc{#2@g.bcp47.region}{bcp47.region}
  \cs_gset_eq:cc{#2@g.bcp47.script}{bcp47.script}
  \cs_gset_eq:cc{#2@g.bcp47.variant}{bcp47.variant}
  \cs_gset_eq:cc{#2@g.bcp47.extension.t}{bcp47.extension.t}
  \cs_gset_eq:cc{#2@g.bcp47.extension.u}{bcp47.extension.u}
  \cs_gset_eq:cc{#2@g.bcp47.extension.x}{bcp47.extension.x}
  \cs_gset_eq:cc{#2@g.bcp47.casing}{bcp47.casing}
}

\DeclareCommandCopy \setmainlanguage \setdefaultlanguage

% Returns the language ID of the current language
% Currently supported: bcp-47
\DeclareDocumentCommand \languageid {m}
{
    \str_case:nnF {#1}
      {
        {bcp-47}    { \csuse{bcp47.tag} }
        {bcp47}     { \csuse{bcp47.tag} }
      }
      {
        \xpg@error{Invalid~ \string\languageid\space argument:~ #1}
      }
}

% Returns the language ID of the main language
% Currently supported: bcp-47
\DeclareDocumentCommand \mainlanguageid {m}
{
    \str_case:nnF {#1}
      {
        {bcp-47}    { \csuse{bcp47.main.tag} }
        {bcp47}     { \csuse{bcp47.main.tag} }
      }
      {
        \xpg@error{Invalid~ \string\mainlanguageid\space argument:~ #1}
      }
}
% Kernel command to access to BCP-47 data.
% Shared interface with babel.
% We support:
% * language (e.g., de)
% * region (e.g., AT)
% * script (e.g., Latn)
% * variant (e.g., 1901)
% * extension-t (transformation, e.g., en-t-ja)
% * extension-u (additional locale information, e.g., ar-u-nu-latn)
% * extension-x (e.g., classic for la-x-classic)
% * casing (whatever is suitable for \MakeUppercase and friends,
%           usually alias to language but could also be something
%           like el-x-iota or ckb-Latn)
% * tag (the registered full tag)
% and main.* variants thereof
% See https://github.com/latex3/latex2e/issues/1035
\DeclareExpandableDocumentCommand \BCPdata {m}
{
   \cs_if_exist_use:cF{bcp47.#1}
        { \xpg@error{Invalid~ \string\BCPdata\space argument:~ #1} }
}

% main babel name
\cs_new_nopar:Npn \mainlanguagename {}
\cs_new_nopar:Npn \mainbabelname {}
\cs_new_nopar:cpn {bcp47.main.tag} {}
\cs_new_nopar:cpn {bcp47.main.language} {}
\cs_new_nopar:cpn {bcp47.main.region} {}
\cs_new_nopar:cpn {bcp47.main.script} {}
\cs_new_nopar:cpn {bcp47.main.variant} {}
\cs_new_nopar:cpn {bcp47.main.extension.t} {}
\cs_new_nopar:cpn {bcp47.main.extension.u} {}
\cs_new_nopar:cpn {bcp47.main.extension.x} {}
\cs_new_nopar:cpn {bcp47.main.casing} {}
\cs_new_nopar:Npn \mainlanguagevariant {}%
% Store main language variant for external packages
\define@key{xpg@main@langvariant}{variant}{
  \cs_gset_nopar:Npn \mainlanguagevariant {#1}
}

\cs_new_nopar:Npn \babelname {}
\def\languagevariant{}
% Store current language variant for external packages
\define@key{xpg@set@langvariant}{variant}{
  \def\languagevariant{#1}
}

\newcommand*\polyglossia@set@language@name[2][]{
  \def\languagename{#2}
  \tl_if_blank:nTF {#1}{
     \ifcsundef{#2@gvar}{\def\languagevariant{}}{\def\languagevariant{\csuse{#2@gvar}}}
   }{
     % Register the language options
     \polyglossia@set@lang@options:nnn {#2} {#1} {@xpg@set@langvariant}
     \cs_set_eq:cc{#2@gvar}{languagevariant}
  }%
}


\newcommand*{\resetdefaultlanguage}[2][]{
  \polyglossia@reset@default@language:nn
    {\xpg_alias_add_to_option_i:nn{#2}{#1}}
    {\xpg_alias_base_lang:n{#2}}
}

\cs_new:Nn \__xpg_store_bcp_info:nn
{
  % Store BCP-47 ID and subtags of current language
  \tl_if_blank:nTF {#1}{
    % tag (e.g., en-US)
    \ifcsundef{#2@g.bcp47.tag}{
       \csedef{bcp47.tag}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47 } }
    }{
       \csedef{bcp47.tag}{\csuse{#2@g.bcp47.tag}}
    }
    % language (e.g., en)
    \ifcsundef{#2@g.bcp47.language}{
       \csedef{bcp47.language}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-language } }
    }{
       \csedef{bcp47.language}{\csuse{#2@g.bcp47.language}}
    }
    % region (e.g., US)
    \ifcsundef{#2@g.bcp47.region}{%
       \csedef{bcp47.region}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-region } }
    }{
       \csedef{bcp47.region}{\csuse{#2@g.bcp47.region}}%
    }
    % script (e.g., Latn)
    \ifcsundef{#2@g.bcp47.script}{
       \csedef{bcp47.script}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-script } }
    }{
       \csedef{bcp47.script}{\csuse{#2@g.bcp47.script}}
    }
    % variant (e.g., 1996)
    \ifcsundef{#2@g.bcp47.variant}{
       \csedef{bcp47.variant}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-variant } }
    }{
       \csedef{bcp47.variant}{\csuse{#2@g.bcp47.variant}}
    }
    % extension.t (tranformation)
    \ifcsundef{#2@g.bcp47.extension.t}{%
       \csedef{bcp47.extension.t}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-extension-t } }
    }{
       \csedef{bcp47.extension.t}{\csuse{#2@g.bcp47.extension.t}}
    }
    % extension.u (additional locale information)
    \ifcsundef{#2@g.bcp47.extension.u}{%
       \csedef{bcp47.extension.u}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-extension-u } }
    }{
       \csedef{bcp47.extension.u}{\csuse{#2@g.bcp47.extension.u}}
    }
    % extension.x (private use area)
    \ifcsundef{#2@g.bcp47.extension.x}{
       \csedef{bcp47.extension.x}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-extension-x } }
    }{
       \csedef{bcp47.extension.x}{\csuse{#2@g.bcp47.extension.x}}
    }
    % casing
    \ifcsundef{#2@g.bcp47.casing}{
       % For casing, we fall back to language if bcp47-casing is not explicitly set
       \cs_set_nopar:cpx {tmpcasing} { \prop_item:Ne \polyglossia@langsetup { #2 / bcp47-casing } }
       \str_if_empty:NTF \tmpcasing
           { \cs_gset_eq:cc {bcp47.casing} {bcp47.language} }
           { \csedef{bcp47.casing}{ \tmpcasing } }
    }{
       \csedef{bcp47.casing}{\csuse{#2@g.bcp47.casing}}
    }
  }{
    \csedef{bcp47.tag}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47 } }
    \csedef{bcp47.language}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-language } }
    \csedef{bcp47.region}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-region } }
    \csedef{bcp47.script}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-script } }
    \csedef{bcp47.variant}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-variant } }
    \csedef{bcp47.extension.t}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-extension-t } }
    \csedef{bcp47.extension.u}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-extension-u } }
    \csedef{bcp47.extension.x}{ \prop_item:Nn{ \polyglossia@langsetup}{ #2 / bcp47-extension-x } }
    % For casing, we fall back to language if bcp47-casing is not explicitly set
    \cs_set_nopar:cpx {tmpcasing} { \prop_item:Ne \polyglossia@langsetup { #2 / bcp47-casing } }
    \str_if_empty:NTF \tmpcasing
         { \cs_gset_eq:cc {bcp47.casing} {bcp47.language} }
         { \csedef{bcp47.casing}{ \tmpcasing } }
  }
}

\cs_new:Nn \polyglossia@reset@default@language:nn
{
  \polyglossia@error@iflangnotloaded:n{#2}
  % disable globalnumbers of previously defined default language
  \csuse{no\xpg@main@language @globalnumbers}
  \csuse{noextras@\xpg@main@language}%
  % This is a hook for external packages which want to access variants
  % via babelname (such as biblatex)
  \cs_if_exist_use:c{noextras@bbl@\mainbabelname}%
  \csuse{init@noextras@\xpg@main@language}%
  \polyglossia@set@language@name[#1]{#2}%
  \__xpg_if_LR_str:eF{\prop_item:Ne{\polyglossia@langsetup}{#2/direction}}
  {
    \@rlmaintrue\@rl@footnotetrue
  }
  \selectlanguage[#1]{#2}%
  \selectbackgroundlanguage{#2}%
  % Store babelname of current language (for external packages such as biblatex)
  \tl_if_blank:nTF {#1}{%
    \ifcsundef{#2@gbabelname}{
       \edef\babelname{\prop_item:Nn{\polyglossia@langsetup}{#2/babelname}}
    }{
       \edef\babelname{\csuse{#2@gbabelname}}
    }
  }{
    \edef\babelname{\prop_item:Nn{\polyglossia@langsetup}{#2/babelname}}
  }
  % Store BCP-47 id of current language
  \__xpg_store_bcp_info:nn {#1}{#2}
}

% This saves the normalfont for the latin script since we may change normalfont in other scripts
\let\normalfontlatin=\normalfont

% Provide default fonts (as set with \setmainfont, \setsansfont and \setmonofont)
% for Latin scripts and as a fallback for non-Latin scripts.
\DeclareRobustCommand\xpg@defaultfont@rm{
   \tl_if_empty:NF{\g__fontspec_nfss_enc_tl}{\fontencoding{\g__fontspec_nfss_enc_tl}}
   \fontfamily\rmdefault
   \ifdefined\UseHook\UseHook{rmfamily}\fi
   \selectfont
}
\DeclareRobustCommand\xpg@defaultfont@sf{
   \tl_if_empty:NF{\g__fontspec_nfss_enc_tl}{\fontencoding{\g__fontspec_nfss_enc_tl}}
   \fontfamily\sfdefault
   \ifdefined\UseHook\UseHook{sffamily}\fi
   \selectfont
}
\DeclareRobustCommand\xpg@defaultfont@tt{
   \tl_if_empty:NF{\g__fontspec_nfss_enc_tl}{\fontencoding{\g__fontspec_nfss_enc_tl}}
   \fontfamily\ttdefault
   \ifdefined\UseHook\UseHook{ttfamily}\fi
   \selectfont
}

\def\xpg@patch@fontfamilies{
  % This robustifies the redefinitions of \<xx>family (suggestion by Enrico Gregorio)
  % e.g. to prevent expansion of the \familytype redefinition in auxiliary files
  \csgappto{rmfamily~}{\def\familytype{rm}}
  \csgappto{sffamily~}{\def\familytype{sf}}
  \csgappto{ttfamily~}{\def\familytype{tt}}
}

% These switches activate the default fonts
% Note that a simple \let\rmfamilylatin=\rmfamily
% does not work reliably (see #24)
\cs_gset_eq:cc{rmfamilylatin}{xpg@defaultfont@rm}
\cs_gset_eq:cc{sffamilylatin}{xpg@defaultfont@sf}
\cs_gset_eq:cc{ttfamilylatin}{xpg@defaultfont@tt}

\def\xpg@set@familydefault{
  % We need the \edef route here in order
  % to detect both \renewcommand and \let
  % changes.
  \edef\tempa{\familydefault}
  \edef\tempb{\sfdefault}
  \ifcsequal{tempa}{tempb}
     {\def\familytype{sf}}
     {\edef\tempb{\ttdefault}
      \ifcsequal{tempa}{tempb}
         {\def\familytype{tt}}
         {\def\familytype{rm}}}
  \xpg@patch@fontfamilies
  % This (re-)saves the normalfont for the latin script since we may
  % change normalfont in other scripts
  \let\normalfontlatin=\normalfont
  % And for all cases, we also reset \<xx>familylatin
  \cs_gset_eq:cc{rmfamilylatin}{xpg@defaultfont@rm}
  \cs_gset_eq:cc{sffamilylatin}{xpg@defaultfont@sf}
  \cs_gset_eq:cc{ttfamilylatin}{xpg@defaultfont@tt}
}

\def\resetfontlatin{
  \DeclareRobustCommand\rmfamily{\xpg@defaultfont@rm}
  \DeclareRobustCommand\sffamily{\xpg@defaultfont@sf}
  \DeclareRobustCommand\ttfamily{\xpg@defaultfont@tt}
  \xpg@patch@fontfamilies
  \global\let\normalfont=\normalfontlatin
}

\def\selectfontfamilylatin{
  \def\tmp@tt{tt}\def\tmp@sf{sf}
  \ifx\familytype\tmp@tt
    \ttfamilylatin
    \else\ifx\familytype\tmp@sf
      \sffamilylatin
      \else\rmfamilylatin\fi\fi}

\def\xpg@select@fontfamily#1{
  \def\tmp@tt{tt}\def\tmp@sf{sf}
  \ifx\familytype\tmp@tt
    \__xpg_use_or_warn:c{#1@font@tt}
  \else\ifx\familytype\tmp@sf
    \__xpg_use_or_warn:c{#1@font@sf}
      \else\__xpg_use_or_warn:c{#1@font@rm}\fi\fi}

\def\xpg@set@normalfont#1{
  \letcs{\rmfamily}{#1@font@rm}
  \letcs{\sffamily}{#1@font@sf}
  \letcs{\ttfamily}{#1@font@tt}
  \robustify\rmfamily
  \robustify\sffamily
  \robustify\ttfamily
  \gdef\normalfont{\protect\xpg@select@fontfamily{#1}
                   \fontseries{\seriesdefault}\selectfont
                   \fontshape{\shapedefault}
                   \ifdefined\UseHook\UseHook{normalfont}\fi
                   \selectfont}
  \gdef\reset@font{\protect\normalfont}
}

\let\@@fterindentfalse\@afterindentfalse
\def\french@indent{
    \let\@afterindentfalse\@afterindenttrue
    \@afterindenttrue
}
\def\nofrench@indent{
    \let\@afterindentfalse\@@fterindentfalse
    \@afterindentfalse
}

\cs_new_nopar:Npn \selectbackgroundlanguage #1
{%
  \polyglossia@select@background@language:n {\xpg_alias_base_lang:n{#1}}
}
\cs_new:Nn \polyglossia@select@background@language:n
{
  \str_if_eq:eeTF{\prop_item:Nn{\polyglossia@langsetup}{#1/lcscript}}{latin}
                   {}
                   {\xpg@set@normalfont{#1}}
  \csuse{#1@globalnumbers}
}
\cs_generate_variant:Nn \polyglossia@select@background@language:n {e}
%  Declare secondary language #2 with language options #1
\DeclareDocumentCommand \setotherlanguage { O{} m }
{
  \seq_if_in:NeF \__xpg_langs_loaded {#2}
  {
    \polyglossia_load_lang_definition:ee {#1} {#2}
    % define environment and command if not alias
    \str_if_eq:eeT {\prop_item:Ne \__xpg_alias {#2/target}} {#2} {
       \use:c{\prop_item:Ne{\polyglossia@langsetup}
             {#2/DefineCommandsCmd}}
             {#2}
    }
    \polyglossia@set@other@language:ee {\xpg_alias_add_to_option_i:nn{#2}{#1}}
      {\xpg_alias_base_lang:n{#2}}
    \seq_gput_right:Ne \__xpg_langs_loaded {#2}
  }
}

\cs_new:Nn \polyglossia@set@other@language:nn
{
  \polyglossia@register@language:nn{#1}{#2}
  % If a variant is set, store it.
  \gdef\otherlanguagevariant{}
  % Register the language options
  \polyglossia@set@lang@options:nnn {#2} {#1} {@xpg@other@langvariant}

  \csgdef{#2@gvar}{\otherlanguagevariant}
  \prop_get:NeNT \polyglossia@langsetup {#2/babelname} \l_tmpa_tl
    { \xdef\otherlanguagebabelname{\l_tmpa_tl} }
  \cs_gset_eq:cc{#2@gbabelname}{otherlanguagebabelname}
}
\cs_generate_variant:Nn  \polyglossia@set@other@language:nn { ee }


% Store main language variant for external packages
\define@key{xpg@other@langvariant}{variant}{
  \gdef\otherlanguagevariant{#1}
}

\NewDocumentCommand \setotherlanguages { m }
  {
   \clist_map_function:eN { #1 } \setotherlanguage
  }

\def\common@language{% FIXME is this really needed???
  \ifbool{xpg@hyphenation@disabled}{
    \xdef\xpg@lastlanguage{\z@}
  }{
    \language=\z@
  }
  \lefthyphenmin=\tw@
  \righthyphenmin=\thr@@}

\def\xpg@initial@setup{
  \common@language
}


% Alias to \text<lang>, but more suitable
% for specific (esp. tag-based) aliases
% where \text<alias> would cause clashes
% (e.g., \textit)
\newcommand\textlang[3][]{
  \__xpg_textlanguage:een {#1} {#2} {#3}
}

% prevent the language tag in \textlang 
% (second argument) from being affected
% inside case changing commands (e.g. \MakeUppercase)
\tl_put_right:Nn \l_text_case_exclude_arg_tl { \textlang }

% Alias to {<lang>}, but more suitable
% for specific (esp. tag-based) aliases
% where {<alias>} would cause clashes
% (e.g., \fi)
\DeclareEnvironmentCopy { lang } { otherlanguage }

% wrapper for foreignlanguage and otherlanguage*
\newcommand*\polyglossia@setforeignlanguage[2][]{
  \select@@language[#1]{#2}
  \polyglossia@register@language:nn{#1}{#2}
  % Store babelname of current language (for external packages such as biblatex)
  \tl_if_blank:nTF {#1}{
    \ifcsundef{#2@gbabelname}{
       \edef\babelname{\prop_item:Nn{\polyglossia@langsetup}{#2/babelname}}
    }{
       \edef\babelname{\csuse{#2@gbabelname}}
    }
  }{
    \edef\babelname{\prop_item:Nn{\polyglossia@langsetup}{#2/babelname}}
  }
  % Store BCP-47 id of current language
  \__xpg_store_bcp_info:nn {#1}{#2}
}

% Expandable lowercasing. We use this to assure keyval
% options are lowercased (also when used in \MakeUppercase
% contexts e.g. in headings)
% Macro adapted from tudscr.sty
\newcommand*\xpg@str@lowercase[2]{
  \protected@edef#1{
    \lowercase{\def\noexpand#1{#2}}
  }#1
}

% lowercase options before passing to setkeys
\cs_new:Nn \polyglossia@set@keys:nn
{
    \xpg@str@lowercase{\xpg@tmp@opts}{#2}
    \exp_args:Nne \setkeys{#1}{\xpg@tmp@opts}
}

% joint code of \foreignlanguage, otherlanguage*
% and \text<lang>
% #1 option
% #2 language
\newcommand{\xpg@otherlanguage}[2][]
{
  \polyglossia@error@iflangnotloaded:n{#2}
  \polyglossia@set@keys:nn{#2}{#1}
  \polyglossia@setforeignlanguage[#1]{#2}
  % Hook for external packages such as biblatex
  \polyglossia@language@switched
  % buggy restoration heure
  \csuse{inlineextras@#2}
  % This is a hook for external packages which want to access variants
  % via babelname (such as biblatex)
  \cs_if_exist_use:c{inlineextras@bbl@\babelname}
}

\DeclareDocumentCommand { \foreignlanguage } { O{} m m }
  {
	\__xpg_foreignlanguage:eeen {#1} {#2} {\xpg_alias_base_lang:n{#2}} {#3}
  }

% Direct access to polyglossia@setforeignlanguage
% used in captions
\newcommand{\setforeignlanguage}[2][]
{
  \polyglossia@setforeignlanguage[#1]{#2}
}

% Stack to store matrix languages
\seq_new:N \__xpg_current_matrixlang_stack

% Store embedding language when an embedded language is switched to
\cs_new_nopar:Nn \__xpg_store_matrixlang:
{
   \seq_gput_left:Nn \__xpg_current_matrixlang_stack \languagename
}

% When an embedded language is closed, reset to the embedding language
% and remove stored matrix language from stack
\cs_new_nopar:Nn \__xpg_reset_to_matrixlang:
{
  % if stack is empty, use main language
  \seq_gpop_left:NNTF \__xpg_current_matrixlang_stack \l_tmpa_tl
     { \cs_set_eq:NN \__xpg_current_matrixlang \l_tmpa_tl }
     { \cs_set_eq:NN \__xpg_current_matrixlang \mainlanguagename }
  % Reset the language's/script's font families if the embedding script is latin
  \str_if_eq:eeT{\prop_item:Ne{\polyglossia@langsetup}{\__xpg_current_matrixlang/lcscript}}{latin}
       {\resetfontlatin}
  % In case a \<lang>font is defined, re-activate that
  \exp_args:Ne \xpg@set@normalfont{\__xpg_current_matrixlang}
}

% internal wrapper for foreign language
% #1 option
% #2 alias
% #3 base lang
% #4 text
\cs_new:Nn \__xpg_foreignlanguage:nnnn
{
  \tl_if_blank:nTF {#3}
  {
    \msg_show:nnn { polyglossia } { languagenotloaded } {#2}
  }{
    \__xpg_store_matrixlang:
    \group_begin:
      \xpg@otherlanguage[\xpg_alias_add_to_option_i:nn{#2}{#1}]{#3}
      \polyglossia@lang@settextdirection:nn{#3}{#4}
    \group_end:
    \__xpg_reset_to_matrixlang:
  }
}
\cs_generate_variant:Nn \__xpg_foreignlanguage:nnnn {eeen}


% otherlanguage* is the environment equivalent of \foreignlanguage
\DeclareDocumentEnvironment { otherlanguage* } { O{} m }
  {
	\__xpg_store_matrixlang:
	\__xpg_otherlanguage:eee { #1 } { #2 } { \xpg_alias_base_lang:n { #2 } }
  }{
	\group_end:
	\__xpg_reset_to_matrixlang:
  }

% internal wrapper
% #1 option
% #2 alias
% #3 base lang
\cs_new:Nn \__xpg_otherlanguage:nnn
{
  \tl_if_blank:nTF {#3}
  {
    \msg_show:nnn { polyglossia } { languagenotloaded } {#2}
  }{
    \xpg@otherlanguage[\xpg_alias_add_to_option_i:nn{#2}{#1}]{#3}
    \polyglossia@lang@settextdirection:nn{#3}%
    \bgroup
  }
}
\cs_generate_variant:Nn \__xpg_otherlanguage:nnn { eee }

% use by \text<lang> and \textlang. Equivalent to \foreignlanguage,
% except that dates are localized.
% #1: option
% #2: alias
% #3: text
\cs_new:Nn \__xpg_textlanguage:nnn
{
  \__xpg_textlanguage:nnen {#1} {#2} {\xpg_alias_base_lang:n{#2}} {#3}
}
\cs_generate_variant:Nn \__xpg_textlanguage:nnn {een}

% Track whether we are in an inline lang (\text...) switch
\bool_new:N \__xpg_inline_lang

% use by \text<lang> and \textlang. Equivalent to \foreignlanguage,
% except that dates are localized.
% #1: option
% #2: alias
% #3: base language
% #4: text
\cs_new:Nn \__xpg_textlanguage:nnnn
{
  \tl_if_blank:nTF {#3}
  {
    \msg_show:nnn { polyglossia } { languagenotloaded } {#2}
  }
  {
    \__xpg_store_matrixlang:
    \group_begin:
      \bool_set_true:N \__xpg_inline_lang
      \xpg@otherlanguage[#1]{#3}
      \csuse{date#3}
      % This is a hook for external packages which want to access variants
      % via babelname (such as biblatex)
      \cs_if_exist_use:c{date@bbl@\babelname}
      \polyglossia@lang@settextdirection:nn{#3}{#4}
    \group_end:
    \__xpg_reset_to_matrixlang:
  }
}
\cs_generate_variant:Nn \__xpg_textlanguage:nnnn {nnen}

% Define language-specific hyphenation exceptions
\newcommand\pghyphenation[3][]{
  \bgroup
  \polyglossia@error@iflangnotloaded:n{#2}
  \setkeys{#2}{#1}
  \select@@language[#1]{#2}
  \hyphenation{#3}
  \egroup
}


% Hook that other package authors can use
% (for instance biblatex):
\newcommand*{\xpg@hook@setlanguage}{}

\def\xpg@pop@language@i#1#2{
  \xpg@set@language@aux[#1]{#2}
  \xpg@hook@setlanguage
  \let\emp@langname\@undefined}

\DeclareDocumentCommand \selectlanguage {s O{} m}
  {
    \tl_if_blank:eTF {\xpg_alias_base_lang:n{#3}}
      {
	\IfBooleanTF { #1 }
          { \msg_show:nnn { polyglossia } { languagenolongerloaded } {#3} }
          { \msg_show:nnn { polyglossia } { languagenotloaded } {#3} }
      }{
        \polyglossia@select@language:nee {#1}
          { \xpg_alias_add_to_option_i:nn{#3}{#2} }
          { \xpg_alias_base_lang:n{#3} }
      }
  }

\cs_new:Nn \polyglossia@select@language:nnn
{
  \IfBooleanTF { #1 }   % The starred variant does not write to the aux
    {
	  \xpg@set@language@nonaux[#2]{#3}
    }{
      \cs_set_nopar:Npe \xpg@pop@language { \exp_not:N \xpg@pop@language@i {#2} {#3} }
      \group_insert_after:N \xpg@pop@language
	  \xpg@set@language@aux[#2]{#3}
    }
  % Register the language options
  \polyglossia@set@lang@options:nnn {#3} {#2} {@xpg@set@langvariant}
  \polyglossia@register@language:nn{#2}{#3}
}
\cs_generate_variant:Nn \polyglossia@select@language:nnn { nee, nne }


% set lang option #2 for lang #1
\cs_new:Nn \polyglossia@set@lang@options:nnn
{
  \tl_if_blank:nF {#2}
  {
    % If the optional argument sets a value for the key “variant”, copy it to xpg@langvariant
    \clist_map_inline:nn { #2 } {
      \xpg@parsevariantkeyvalue##1=#3:#1\relax
    }%
    \polyglossia@set@keys:nn{#1}{#2}
  }
}

% Initialize default language options, so that
% \iflanguageoption has the info it needs also
% for default settings
\newcommand*\xpg@initialize@gloss@options[2]{
   \polyglossia@set@lang@options:nnn {#1} {#2} {@xpg@set@langvariant}
}

% Record synonymous keyvals such as variant=us and variant=american
% Syntax: \xpg@set@alias@values{<lang>}{<key>}{<val>}{<alias vals, comma-separated>}
\newcommand*\xpg@set@alias@values[4]{%
   \prop_if_exist:cF { xpg@alias@keyvals@#1@#3 }
      { \prop_new:c {xpg@alias@keyvals@#1@#3} }
   \prop_put:cnn { xpg@alias@keyvals@#1@#3 }
      {#2}{#4}
   \prop_put:cnn { xpg@alias@keyvals@#1@#4 }
      {#2}{#3}
}

% Patch xkeyval to record default values of keys
\pretocmd{\XKV@define@default}{%
   \csgdef{xpg@default@opt@\XKV@header #1}{#2}
}{}{\xpg@warning{Patching xkeyval failed!}}

% Helper to get and register option keyvals
\def\xpg@parsevariantkeyvalue#1=#2@#3:#4\relax{
   \def\@tmpa{#1}
   \def\@tmpb{variant}
   % variant values are stored in specific macros
   % (\xpg@main@langvariant, \xpg@other@langvariant
   % and \xpg@set@langvariant)
   \ifx\@tmpa\@tmpb\setkeys{#3}{#1=#2}\fi
   \tl_if_empty:nTF{#2}
      {
        \ifcsdef{xpg@default@opt@KV@#4@#1}
           {\xpg@store@opt@keyval#1:\csuse{xpg@default@opt@KV@#4@#1}=:#4\relax}
           {}%
      }
      { \xpg@store@opt@keyval#1:#2:#4\relax }
}%

% Store option keys and values
% This strips trailing '=' from values.
\def\xpg@store@opt@keyval#1:#2=:#3\relax{
   \prop_if_exist:cF { xpg@current@options@#3 }
      { \prop_new:c {xpg@current@options@#3} }
   \prop_put:cnn { xpg@current@options@#3 }
      {#1}{#2}
}


\prg_set_conditional:Npnn \polyglossia@check@option@value:NNN #1#2#3 { p , T , F , TF }
{
  \prop_get:cnNTF {xpg@current@options@#1} {#2} \l_tmpa_tl
     {
       \str_if_eq:eeTF{\l_tmpa_tl}{#3}
          {\prg_return_true:}
          {
            \prop_get:cnNTF {xpg@alias@keyvals@#1@#3} {#2} \l_tmpb_tl
               {
                \clist_set:Ne{\l_tmpa_clist}{\l_tmpb_tl}
                \providetoggle{xpgvalfound}
                \togglefalse{xpgvalfound}
                \clist_map_inline:Nn \l_tmpa_clist {
                   \str_if_eq:eeT{##1}{\l_tmpa_tl}
                      { \toggletrue{xpgvalfound} }
                }
                \iftoggle{xpgvalfound}{\prg_return_true:}{\prg_return_false:}
              }
              {
                \prg_return_false:
              }
         }
     }
     {
       \prg_return_false:
     }
}

% Test if option value is set
\DeclareDocumentCommand \iflanguageoption { m m m m m }
{
  \polyglossia@check@option@value:NNNTF{#1}{#2}{#3}{#4}{#5}
}


% Append any variant to csv list of variants
\define@key{xpg@langvariant}{variant}{
  \clist_if_in:NeF \xpg@vloaded {#1}{
    \clist_gput_right:Ne \xpg@vloaded {#1}
  }
}

% Test if language is loaded
\DeclareDocumentCommand \iflanguageloaded { m m m }
{
   \AddToHook{begindocument/end}{
     \clist_if_in:NeTF \xpg@loaded{#1}{#2}{#3}
   }
}

% Same for babellanguage is loaded
\DeclareDocumentCommand \ifbabellanguageloaded { m m m }
{
  \AddToHook{begindocument/end}{
     \clist_if_in:NeTF \xpg@bloaded{#1}{#2}{#3}
  }
}

% Same for languageid
\DeclareDocumentCommand \iflanguageidloaded { m m m m }
{
  \AddToHook{begindocument/end}{
    \str_case:nnTF {#1}
      {
        {bcp-47}    { \clist_if_in:NeTF \xpg@bcp@loaded{#2}{#3}{#4} }
        {bcp47}     { \clist_if_in:NeTF \xpg@bcp@loaded{#2}{#3}{#4} }
      }
      {}
      {
        \xpg@error{Invalid~ \string\iflanguageidloaded\space argument:~ #1}
      }
   }%
}

% Check if the current font has a given glyph
\prg_new_conditional:Npnn \__polyglossia_if_char:N #1 { TF }
  {
    \iffontchar\font\int_from_hex:n { #1 }~
		\prg_return_true:
	\else:
		\prg_return_false:
	\fi:
  }

% Test if a char (by char code) is available in the current font
% and print it, if so, otherwise print the replacement #2
\NewExpandableDocumentCommand \charifavailable { m m }
  {
    \exp_args:Nno \__polyglossia_if_char:NTF { #1 } { \Uchar"#1 } { #2 }
  }

% Test if a char (by char code) is available in the current font
% if so, do #2, else do #3
\NewExpandableDocumentCommand \IfCharIsAvailableTF { m m m }
  {
    \__polyglossia_if_char:NTF { #1 } { #2 } { #3 }
  }


\newcommand*{\xpg@set@language@nonaux}[2][]{
   \@select@language[#1]{#2}
}


\newcommand*{\xpg@set@language@aux}[2][]{
   % Store babelname of current language (for external packages such as biblatex)
   \tl_if_blank:nTF {#1}{
     \ifcsundef{#2@gbabelname}{
        \edef\babelname{\prop_item:Nn{\polyglossia@langsetup}{#2/babelname}}
     }{
        \edef\babelname{\csuse{#2@gbabelname}}
     }
   }{
     \edef\babelname{\prop_item:Nn{\polyglossia@langsetup}{#2/babelname}}
   }
   % Store BCP-47 id of current language
   \__xpg_store_bcp_info:nn {#1}{#2}
   \@select@language[#1]{#2}
    % Write to the aux
   \xpg@set@language@only@aux[#1]{#2}
}

\newcommand*{\xpg@set@language@only@aux}[2][]{
    % Write to the aux (toc files)
   \if@filesw
        \addtocontents{toc}{\selectlanguage*[#1]{#2}}
   \fi
}

\AtBeginDocument{
   \if@filesw
		\immediate\write\@mainaux
		{\ProvideDocumentCommand\selectlanguage{sO{}m}{}}
   \fi
}

% Since captions might float to other language regions,
% we need to change the language here (#542)
\AddToHook{cmd/caption/before}{
    \ifhmode\unskip\fi
    \addtocontents{lof}{\protect\setforeignlanguage{\languagename}}
    \addtocontents{lot}{\protect\setforeignlanguage{\languagename}}
}

% check if language is defined
\prg_set_conditional:Npnn \__xpg_check_if_exist_l@:n #1 { F, TF }
  {
	\bool_lazy_and:nnTF 
	  { \cs_if_exist_p:c { l@#1 }  }
	  { ! (\cs_if_eq_p:cc { l@#1 } { l@nohyphenation }) }
	  { \prg_return_true: }
      { \prg_return_false: }
  }

\def\polyglossia@luatex@load@lang#1{
  % if \l@#1 is not properly defined, call lua function newloader(#1),
  % and assign the returned number to \l@#1
  \__xpg_check_if_exist_l@:nF {#1}
  {
    \directlua { token.set_char('l@#1', polyglossia.newloader'#1') }
  }
}

% This check is also used by biblatex, so don't
% rename silently.
\newcommand\xpg@ifdefined[3]{
  % With luatex, we first need to define \l@#1.
  \sys_if_engine_luatex:T
  {
    \polyglossia@luatex@load@lang{#1}
  }
  \__xpg_check_if_exist_l@:nTF{#1}{#2}{#3}
}

% Set \bbl@hyphendata@\the\language, which is (lua)babel's
% hyphenation pattern hook
% FIXME Clarifiy why/when this is needed.
\newcommand*\xpg@set@bbl@hyphendata[1]{
  \sys_if_engine_luatex:T
  {
    \ifcsdef{bbl@hyphendata@#1}{}{
      \global\@namedef{bbl@hyphendata@\the\language}{}
    }
  }
}

% Set hyphenation patterns for a given language. This does the right
% thing both for XeTeX and LuaTeX
\newcommand*\xpg@set@hyphenation@patterns[1]{
  \sys_if_engine_luatex:T { \polyglossia@luatex@load@lang{#1} }
  \language=\csname l@#1\endcsname
}

\newcommand*\@select@language[2][]{
   % hook for compatibility with biblatex
   \select@language{#2}
   \xpg@set@bbl@hyphendata{\the\language}
   \xpg@initial@setup%
   \select@@language[#1]{#2}%
   % Hook for external packages such as biblatex
   \polyglossia@language@switched%
   \polyglossia@lang@setpardirection:n{#2}
   \csuse{captions#2}%
   \csuse{date#2}%
   % These are hooks for external packages which want to access variants
   % via babelname (such as biblatex)
   \cs_if_exist_use:c{captions@bbl@\babelname}
   \cs_if_exist_use:c{date@bbl@\babelname}
   \polyglossia@local@marks:n{#2}
   \csuse{init@extras@#2}%
   \xpg__indent_first:n { #2 }
   \csuse{blockextras@#2}%
   % This is a hook for external packages which want to access variants
   % via babelname (such as biblatex)
   \cs_if_exist_use:c{blockextras@bbl@\babelname}
 }

% hook for compatibility with biblatex
% (probably no longer used due to the
%  more general hook that follows, but
%  we keep it for backwards comp.)
\def\select@language#1{}

% Hook for external packages such as biblatex
\def\polyglossia@language@switched{}

% remove all custumization for language #1
\cs_new:Npn \noextrascurrent #1
{%
  \cs_if_exist_use:c{noextras@#1}%
  % This is a hook for external packages which want to access variants
  % via babelname (such as biblatex)
  \cs_if_exist_use:c{noextras@bbl@\babelname}
}

% Common code for `\select@language' and `\foreignlanguage'.
\newcommand{\select@@language}[2][]{%
  % disable the extras and number settings of the previous language
  \cs_if_exist:cT{languagename}
  {
    \noextrascurrent{\languagename}
    \cs_if_exist_use:c{no\languagename @numbers}
    \sys_if_engine_xetex:T{
      \__xpg_if_LR_str:eTF{\prop_item:Ne{\polyglossia@langsetup}{\languagename/direction}}
      {
        \__xpg_if_LR_str:eF{\prop_item:Nn{\polyglossia@langsetup}{#2/direction}}
          {\setnonlatin} % LTR -> RTL
      }
      {
        \__xpg_if_LR_str:eT{\prop_item:Nn{\polyglossia@langsetup}{#2/direction}}
          {\setlatin} % RTL -> LTR
      }
    }
  }
  \polyglossia@set@language@name[#1]{#2}
  % Set the language's/script's font families
  \str_if_eq:eeT{\prop_item:Nn{\polyglossia@langsetup}{#2/lcscript}} {latin}
  {
    \resetfontlatin
  }
  \bool_if:NF \__xpg_inline_lang
  { % This for non-inline font switches
    % in case a \<lang>font is defined
    \xpg@set@normalfont{#2}
  }
  \xpg@select@fontfamily{#2}
  \__xpg_use_or_warn:c{#2@language}
  \cs_if_exist_use:c{#2@numbers}
  \use@localhyphenmins[#1]{#2}
  \xpg__french_spacing:n { #2 }
}


\let\xpg@pop@language\relax

%
% Keep track of the active (nested) languages and options
%
\clist_new:N \l_xpg_lang_stack

\cs_new:Nn \polyglossia@stack@language:nn
{
  \clist_gpush:Nn \l_xpg_lang_stack {#1:#2}
}

\cs_generate_variant:Nn \polyglossia@stack@language:nn {nx}

\cs_new:Nn \polyglossia@unstack@language:n
{
  \clist_gpop:NNTF \l_xpg_lang_stack \l_tmpa_tl {
     % Stored format = options:language => split:
     \seq_set_split:Nne \l_tmpa_seq {:} \l_tmpa_tl
     \seq_get_left:NN \l_tmpa_seq \l_tmpb_tl
     \seq_get_right:NN \l_tmpa_seq \l_tmpc_tl
     % Execute passed command with language and maybe options
     % and re-set stored language's keys
     \tl_if_empty:NTF \l_tmpb_tl {\cs_if_exist_use:c{#1}{\l_tmpc_tl}}
                                 {\polyglossia@set@keys:nn{\l_tmpc_tl}{\l_tmpb_tl}
                                  \cs_if_exist_use:c{#1}[\l_tmpb_tl]{\l_tmpc_tl}
                                 }
  }
  {}
}

\DeclareDocumentEnvironment { otherlanguage } { O{} m }
  {
    % Get real current (pre-switch) options (incl. defaults)
    \clist_clear_new:N \l_xpg_current_options
    \prop_map_inline:cn {xpg@current@options@\languagename}
      {
        \clist_put_right:Nn \l_xpg_current_options {##1=##2}
      }
    % Store current (pre-switch) options and language on stack
    \polyglossia@stack@language:nx{\clist_use:Nn \l_xpg_current_options {,}}{\languagename}
    \selectlanguage[#1]{#2}
  }
  {
    % restore previous language in aux file and remove closed one from stack
    \polyglossia@unstack@language:n{xpg@set@language@only@aux}
  }

\newcommand{\setlocalhyphenmins}[3]{
   \xpg@ifdefined{#1}{
      \expandafter\ifx\csname l@#1\endcsname\l@nohyphenation
        \xpg@warning{\string\setlocalhyphenmin\space~ useless~ for~ unhyphenated~ language~ #1}
      \else
      \providehyphenmins{#1}{#2#3}
      \fi
   }{
     \xpg@warning{\string\setlocalhyphenmin\space~ useless~ for~ unknown~ language~ #1}
   }
}

% \setlanghyphenmins[options]{lang}{l}{r}
\newcommand*\setlanghyphenmins[4][]{%
  % Check for real language name and options
  \edef\xpg@tmp@opts{\xpg_alias_add_to_option_i:nn{#2}{#1}}
  \edef\xpg@tmp@lang{\xpg_alias_base_lang:n{#2}}
  \bgroup
  \polyglossia@error@iflangnotloaded:n{\xpg@tmp@lang}
  \polyglossia@set@keys:nn{\xpg@tmp@lang}{\xpg@tmp@opts}
  % Store bcp47.tag@hypenmins
  \tl_if_blank:nTF {\xpg@tmp@opts}{%
    \ifcsundef{\csname xpg@tmp@lang\endcsname @g.bcp47.tag}{
       \csedef{tmp@bcp47.tag}{\prop_item:Ne{\polyglossia@langsetup}{ \xpg@tmp@lang / bcp47 }}
    }{
       \csedef{tmp@bcp47.tag}{\csuse{#2@g.bcp47.tag}}
    }
  }{
    \csedef{tmp@bcp47.tag}{\prop_item:Ne{\polyglossia@langsetup}{ \xpg@tmp@lang / bcp47 }}
  }
  \csgdef{\csname tmp@bcp47.tag\endcsname @hyphenmins}{{#3}{#4}}
  \egroup
}

% \use@localhypenmins[options]{lang}
\newcommand*\use@localhyphenmins[2][]{
  \bgroup
  \polyglossia@error@iflangnotloaded:n{#2}
  \polyglossia@set@keys:nn{#2}{#1}
  % Use bcp47.tag@hypenmins
  \tl_if_blank:nTF {#1}{
    \ifcsundef{#2@g.bcp47.tag}{
       \csxdef{tmp@bcp47.tag}{\prop_item:Nn{\polyglossia@langsetup}{ #2 / bcp47 }}
    }{
       \csxdef{tmp@bcp47.tag}{\csuse{#2@g.bcp47.tag}}
    }
  }{
    \csxdef{tmp@bcp47.tag}{\prop_item:Nn{\polyglossia@langsetup}{ #2 / bcp47 }}
  }
  \egroup
  \ifcsundef{\csname tmp@bcp47.tag\endcsname @hyphenmins}{
     \ifcsundef{#2hyphenmins}{}
        {
          \expandafter\expandafter\expandafter\set@hyphenmins\csname #2hyphenmins\endcsname\relax
        }
   }{
      \edef\tmpa{\csuse{\csname tmp@bcp47.tag\endcsname @hyphenmins}}
      \expandafter\expandafter\expandafter\set@hyphenmins\tmpa\relax
   }
   \sys_if_engine_luatex:T{
     % Set \totalhyphenmin if specified
     \prop_get:NeNTF \polyglossia@langsetup {#2/totalhyphenmin} \l_tmpa_tl
     {
        \xpg@info{totalhyphenmin: '\l_tmpa_tl'}
        \expandafter\hyphenationmin \l_tmpa_tl
     }
     {}
   }
}

% Babel previously compiled in hyphenrules into the kernel (via hyphen.cfg)
% but this is no longer the case. In any case, we roll our own one now
% and possibly overwrite babel's.
% As opposed to the one inherited from switch.def/babel, our environment
% supports language options and aliases.
\DeclareDocumentEnvironment { hyphenrules } { O{} m }
  {
    % Check for real language name and options
    \edef\xpg@tmp@opts{\xpg_alias_add_to_option_i:nn{#2}{#1}}
    \edef\xpg@tmp@lang{\xpg_alias_base_lang:n{#2}}
    % Register the language options
    \polyglossia@set@lang@options:nnn {\xpg@tmp@lang} {\xpg@tmp@opts} {@xpg@set@langvariant}
    % Now switch patterns
    \__xpg_use_or_warn:c{\use:c{xpg@tmp@lang}@language}
    % And activate hyphenmins
    \use@localhyphenmins[\xpg@tmp@opts]{\xpg@tmp@lang}
  }
  { }

\AddToHook{begindocument/before}{
   \IfPackageLoadedTF{bidi}{
      \providecommand*{\aemph}[1]{$\overline{\hboxR{#1}}$}
   }{}
   \IfPackageLoadedTF{luabidi}{
      \providecommand*{\aemph}[1]{$\overline{\hbox{\RL{#1}}}$}
   }{}
}


% keys for main package
\keys_define:nn { polyglossia } {
  verbose
     .bool_set:N = \l_polyglossia_verbose_bool,
  verbose
     .default:n = true,
  % compatibility
  quiet
     .meta:n =  { verbose = false },

  localmarks
     .bool_set:N = \l_polyglossia_localmarks_bool,
  localmarks
     .default:n = true,
  % compatibility
  nolocalmarks
     .meta:n = { localmarks = false },
   
  babelshorthands
     .legacy_if_set:n = system@babelshorthands, % compatibility
  babelshorthands
     .default:n = true,

  luatexrenderer
     .cs_set:Np = \l_polyglossia_luatex_renderer,
  luatexrenderer
     .value_required:n = true,
}

\keys_set:nn { polyglossia } {
  localmarks = false,
  verbose = true,
  babelshorthands = false,
  luatexrenderer = Harfbuzz
}

% load by default latex
\setmainlanguage{latex}
% then process key in order to overwrite
\ProcessKeyOptions[polyglossia]

% Set the LuaTeX renderer. As opposed to fontspec, we use Harfbuzz by default.
% This can be changed via the luatexrenderer package option.
\sys_if_engine_luatex:T{
  \str_if_eq:eeF{\l_polyglossia_luatex_renderer}{none}
  {
    \xpg@info{Setting~ LuaTeX~ font~ renderer~ to~ \l_polyglossia_luatex_renderer}
    \exp_args:Ne \defaultfontfeatures{Renderer=\l_polyglossia_luatex_renderer}
  }
}

\bool_if:nF \l_polyglossia_verbose_bool {
   \gdef\@latex@info#1{\relax} % no latex info
   \gdef\@font@info#1{\relax} % no latex font info
   \gdef\@font@warning#1{\relax} % no latex font warnings
   \gdef\zf@PackageInfo#1{\relax} % no fontspec info
   \gdef\xpg@info#1{\relax} % no polyglossia info
}

\bool_if:nT \l_polyglossia_localmarks_bool {
  \polyglossia@enable@local@marks:
}

% Control shorthand (de-)activation
% This checks that the shorthand char is only deactivated
% if we have activated it ourselves and hence keeps
% activation of other packages if no shorthands are used.
\seq_new:N \__xpg_active_shorthands

\DeclareDocumentCommand \xpg@activate@shorthands { O{"} }
{
  \seq_if_in:NnF \__xpg_active_shorthands { #1 }
    {
     \bbl@activate{#1}
     \seq_gpush:Nn \__xpg_active_shorthands { #1 }
    }
}

\DeclareDocumentCommand \xpg@deactivate@shorthands { O{"} }
{
  \seq_if_in:NnT \__xpg_active_shorthands { #1 }
    {
     \cs_if_exist:cT{initiate@active@char}{\bbl@deactivate{#1}}
     \seq_remove_all:Nn \__xpg_active_shorthands {#1}
    }
}

% Inherit shorthands in other languages
\NewDocumentCommand \inheritbabelshorthands { m m }
{
   \AddToHook{begindocument/before}{
       % Load the involved languages if necessary
       % Error if they do not exist
       \tl_set:Nn \xpg_tmpa_lang_tl { \xpg_alias_base_lang:n{#1} }
       \clist_if_in:NeF \xpg@loaded {\xpg_tmpa_lang_tl}{
           \file_if_exist:nTF{gloss-\xpg_tmpa_lang_tl .ldf}
              { \setotherlanguage{#1} }
              { \xpg@error{ Source~ language~ #1,~ used~ in~
                            \string\inheritbabelshorthands,~ does~ not~ exist } }
       }
       \tl_set:Nn \xpg_tmpb_lang_tl { \xpg_alias_base_lang:n{#2} }
       \clist_if_in:NeF \xpg@loaded {\xpg_tmpb_lang_tl}{
           \file_if_exist:nTF{gloss-\xpg_tmpb_lang_tl .ldf}
              { \setotherlanguage{#2} }
              { \xpg@error{ Target~ language~ #2,~ used~ in~
                            \string\inheritbabelshorthands,~ does~ not~ exist } }
       }
       % Test whether the requested shorthands exist
       \bool_if_exist:NF \xpg_no_shorthands_bool
           { \bool_new:N \xpg_no_shorthands_bool }
       \cs_if_exist:cF { \xpg_tmpa_lang_tl @shorthands }
                       { \bool_set_true:N \xpg_no_shorthands_bool }
       \cs_if_exist:cF { no\xpg_tmpa_lang_tl @shorthands }
                       { \bool_set_true:N \xpg_no_shorthands_bool }
       \bool_if:nT { \xpg_no_shorthands_bool }
                   {
                      \xpg@error{ No~ babel~ shorthands~ exist~ for~ language~ #1 }
                   }
       % If so, apply:
       \bool_if:nF { \xpg_no_shorthands_bool }
       {
           \exp_args:Ncc \addto { blockextras@\xpg_tmpb_lang_tl } { \xpg_tmpa_lang_tl @shorthands }
           \exp_args:Ncc \addto { inlineextras@\xpg_tmpb_lang_tl } { \xpg_tmpa_lang_tl @shorthands }
           \exp_args:Ncc \addto { noextras@\xpg_tmpb_lang_tl } { no\xpg_tmpa_lang_tl @shorthands }
       }
   }
}

% Activate shorthands of a (loaded) language inline
\NewDocumentCommand \usebabelshorthands { m }
{
    \str_if_eq:nnTF { #1 } { none }
    {
       % "none" deactivates any shorthands
       \languageshorthands{none}
    }
    {
       \tl_set:Nn \xpg_tmpa_lang_tl { \xpg_alias_base_lang:n{#1} }
       \iflanguageloaded{\xpg_tmpa_lang_tl}{
           \use:c{\xpg_tmpa_lang_tl @shorthands}
       }{
           \xpg@error{ Language~ #1,~ requested~ in~
                       \string\startbabelshorthands,~ is~ not~ loaded }
       }
    }
}

\endinput
